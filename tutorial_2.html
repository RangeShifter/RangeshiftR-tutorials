<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Tutorial 2: Landscape-scale connectivity, matrix permeability and dispersal behaviour</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">RangeShiftR tutorials</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">About RangeShiftR</a>
</li>
<li>
  <a href="installing.html">Installing RangeShiftR</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    RangeShiftR tutorials
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="overview_0.html">0. General package introduction</a>
    </li>
    <li>
      <a href="tutorial_1.html">1. Range expansion</a>
    </li>
    <li>
      <a href="tutorial_2.html">2. Patch connectivity</a>
    </li>
    <li>
      <a href="tutorial_3.html">3. Dynamic landscapes &amp; SMS paths</a>
    </li>
    <li>
      <a href="tutorial_4.html">4. Evolution of dispersal</a>
    </li>
    <li>
      <a href="appendix_tutorial_3.html">Appendix A3. Create dynamic landscapes</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="mailto:RangeShiftR@uni-potsdam.de">
    <span class="fa fa-envelope"></span>
     
  </a>
</li>
<li>
  <a href="https://rangeshifter.github.io">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/RangeShifter">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://twitter.com/ZurellLab">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Tutorial 2: Landscape-scale connectivity, matrix permeability and dispersal behaviour</h1>

</div>


<p>In this second example, <code>RangeShiftR</code> is used at the landscape scale to model functional connectivity of a woodland network for a hypothetical woodland species. The aims are:</p>
<ul>
<li>to illustrate how the platform can be used to investigate connectivity issues as well as species spatial dynamics at local and landscape scales;</li>
<li>to show how the platform can run a model as patch-based;</li>
<li>to show how additional complexity in the population dynamics and dispersal behaviour can be incorporated;</li>
<li>and to show how the connectivity analyses can be dependent upon the type of model and on the modelled dispersal behaviour.</li>
</ul>
<p>We want to reproduce Figure 3 of <span class="citation">Bocedi et al. (2014)</span>. To this end, we run four different scenarios:</p>
<ol style="list-style-type: lower-alpha">
<li>Explicit sexual model. Constant per-step mortality probability of <em>0.01</em>; individuals settle only if at least one individual of the opposite sex is present in the patch (Figure 3b in the paper).</li>
<li>As in (a), but with different settlement rules. Females settle in suitable patches, while males will settle only if at least one female is present in the patch (Figure 3c in the paper).</li>
<li>Only-female model. Constant per-step mortality probability of <em>0.01</em>; females settle in suitable patches (Figure 3d in the paper).</li>
<li>As in (a), but with habitat-specific per-step mortality (Figure 3e in the paper).</li>
</ol>
<p><span class="citation">Bocedi et al. (2014)</span> defined the measures ‘final probability of occupancy’ and the ‘mean time to first colonisation’ to illustrate the connectivity between the initial patch and the rest of the woodland network. These measures allow rapidly assessing the effects of landscape characteristics and species movement abilities on connectivity and, importantly, also on the population dynamics. Note that both measures represent multi-generation connectivity.</p>
<div id="getting-started" class="section level1">
<h1><span class="header-section-number">1</span> Getting started</h1>
<div id="create-a-rs-directory" class="section level2">
<h2><span class="header-section-number">1.1</span> Create a RS directory</h2>
<p>We need to set up the folder structure again with the three sub-folders named ‘Inputs’, ‘Outputs’ and ‘Output_Maps’.</p>
<pre class="r"><code>library(RangeShiftR)
library(raster)
library(RColorBrewer)
library(rasterVis)
library(latticeExtra)
library(viridis)
library(grid)
library(gridExtra)

# relative path from working directory:
dirpath = &quot;Tutorial_02/&quot;

dir.create(paste0(dirpath,&quot;Inputs&quot;), showWarnings = TRUE)
dir.create(paste0(dirpath,&quot;Outputs&quot;), showWarnings = TRUE)
dir.create(paste0(dirpath,&quot;Output_Maps&quot;), showWarnings = TRUE)</code></pre>
<p>Copy the input files provided for exercise 2 into the ‘Inputs’ folder. The files can be downloaded <a href="files/Tutorial2_Inputs.zip">here</a>.</p>
</div>
<div id="landscape-parameters" class="section level2">
<h2><span class="header-section-number">1.2</span> Landscape parameters</h2>
<p>We use a typical British lowland, agricultural landscape having small fragments of woodland, as used by Forest Research, UK, in Watts et al. (2010). The landscape map has an extent of <em>10km</em> by <em>6km</em> and a resolution of <em>10m</em>. Land-covers were aggregated into seven categories (Figure 3a in <span class="citation">Bocedi et al. (2014)</span>). Similar to tutorial 1, the map, <em>landscape_10m_batch.txt</em>, is a raster map with codes for different land-cover types. Land-covers were aggregated into seven categories which have to be given as sequential integer numbers, starting from one:</p>
<ul>
<li>1 = semi-natural broad-leaved woodland</li>
<li>2 = planted/felled broad-leaved and mixed woodland, shrubs and bracken</li>
<li>3 = heathland, marshy grassland</li>
<li>4 = unimproved grassland, mire</li>
<li>5 = planted/felled coniferous woodland, semi-improved grassland, swamp</li>
<li>6 = improved grasslands, arable, water</li>
<li>7 = roads, buildings</li>
</ul>
<pre class="r"><code>landsc &lt;- raster(paste0(dirpath, &quot;Inputs/landscape_10m_batch.txt&quot;))

# Plot land cover map and highlight cells with initial species distribution - option 2 with categorical legend:
landsc.f &lt;- as.factor(landsc)
# add the land cover classes to the raster attribute table
rat &lt;- levels(landsc.f)[[1]]
rat[[&quot;landcover&quot;]] &lt;- c(&quot;semi-natural broad-leaved woodland&quot;, &quot;planted/felled broad-leaved and mixed woodland&quot;, &quot;heathland, marshy grassland&quot;, &quot;unimproved grassland&quot;, &quot;planted/felled coniferous woodland&quot;, &quot;improved grasslands, arable, water&quot;, &quot;roads, buildings&quot;)
levels(landsc.f) &lt;- rat

levelplot(landsc.f, margin=F, scales=list(draw=FALSE), col.regions=brewer.pal(n = 7, name = &quot;Spectral&quot;))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>The second text file, <em>woodland_1ha_patchIDs.txt</em>, contains the patch-matrix landscape. It has the same extent and resolution as the land-type map, and each cell contains a unique patch ID that indicates to which patch it belongs. Patch number <em>0</em> designates the matrix patch, i.e. all unsuitable habitat.</p>
<pre class="r"><code>patch &lt;- raster(paste0(dirpath, &quot;Inputs/woodland_1ha_patchIDs.txt&quot;))

# We can have a glimpse at how many cells the different patches contain:
table(values(patch))</code></pre>
<pre><code>## 
##      0      1      2      3      4      5      6      7      8      9     10 
## 585734    287    232    243    996    240    238    181    141    990    162 
##     11     12     13     14     15     16     17     18     19     20     21 
##    221    311    207    594    694    118    137    172    245    361    423 
##     22     23     24     25     26     27     28     29     30     31     32 
##    349    145   1141    138    401    280    336    706   1919    249    154 
##     33     34     35     36     37     38     39     40     41     42     43 
##    166    524    215   1277    383    735    113   1008    447    125    100 
##     44     45     46     47     48     49     50 
##    547    116    225    675    189    110    301</code></pre>
<pre class="r"><code># Plot the patches in different colours:
levelplot(patch, margin=F, scales=list(draw=FALSE), at=0:50, colorkey=F,
          col.regions = c(&#39;black&#39;,rep(brewer.pal(n = 12, name = &quot;Paired&quot;),5))
          ) </code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>The last text file, <em>patch30.txt</em>, is a map that specifies the patches that contain the initial distribution of the species. In our case, this is only the patch with ID <em>30</em>.</p>
<pre class="r"><code>patch30 &lt;- raster(paste0(dirpath, &quot;Inputs/patch30.txt&quot;))

# Look at initial patch:
plot(patch30)</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>We are ready to set up the landscape parameter object with these maps, their respective resolutions, and the demographic density dependence for all land cover types. In contrast to tutorial 1, we will use a stage-structured population model here (defined below), so that the values in <code>K_or_DensDep</code> will be used as the parameter <em>1/b</em> in the population dynamics (see <code>?StageStructure</code>), describing the strength density dependence (in fecundity, development and survival).</p>
<p>We choose to define only ‘semi-natural broad-leaved woodland’ (code 1) as suitable for our species.</p>
<pre class="r"><code>land &lt;- ImportedLandscape(LandscapeFile = &quot;landscape_10m_batch.txt&quot;,
                          PatchFile = &quot;woodland_1ha_patchIDs.txt&quot;, 
                          Resolution = 10,
                          Nhabitats = 7,
                          K_or_DensDep = c(10, rep(0,6)),
                          SpDistFile = &quot;patch30.txt&quot;,
                          SpDistResolution = 10)</code></pre>
</div>
</div>
<div id="scenario-a-sexual-model-with-mate-finding" class="section level1">
<h1><span class="header-section-number">2</span> Scenario a: sexual model with mate finding</h1>
<div id="demographic-and-dispersal-parameters" class="section level2">
<h2><span class="header-section-number">2.1</span> Demographic and dispersal parameters</h2>
<p>We will simulate a sexual species with simple, two-staged structured population dynamics. The parameters are chosen to be representative of species having moderately high fecundity, high juvenile mortality and low adult mortality. This is encoded in the following transition matrix</p>
<pre class="r"><code>(trans_mat &lt;- matrix(c(0, 1, 0, 0, 0.1, 0.4, 5, 0, 0.8), nrow = 3, byrow = F))</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0  0.0  5.0
## [2,]    1  0.1  0.0
## [3,]    0  0.4  0.8</code></pre>
<p>The first row and column describe the juvenile stage, the others the two adult stages. Juveniles will develop to the first adult stage at the end of their first year with a probability of <em>1.0</em>, which allows for juvenile dispersal before any mortality happens.</p>
<p>In order to add a stage-structure to our population dynamics, we use the <code>StageStructure()</code> function within the demography module. The reproduction type <em>1</em> denotes a simple sexual model, i.e. mating is not explicitly modelled.</p>
<pre class="r"><code>stg &lt;- StageStructure(Stages=3,           # 1 juvenile + 2 adult stages
                      TransMatrix=trans_mat, 
                      MaxAge=1000, 
                      SurvSched=2, 
                      FecDensDep=T)
demo &lt;- Demography(StageStruct = stg,
                   ReproductionType = 1)  # simple sexual model</code></pre>
<p>After reproduction, we allow only juveniles to disperse, and define a density-dependent emigration probability. To do so, we enable the options <code>DensDep=T</code> and <code>StageDep=T</code>, and in the matrix <code>EmigProb</code> we set the parameters D<sub>0</sub> = <em>0.5</em>, α = <em>10.0</em> and β = <em>1.0</em> for juveniles and to zero for all adult stages.</p>
<p>To account for functional connectivity, we use a mechanistic movement model which enables individuals to interact with the landscape and determine their path according to what they can perceive in the landscape. Therefore we will simulate movements with a stochastic movement simulator (<code>SMS()</code>) where individuals move stepwise (each step goes from one cell to a neighbouring cell) and the direction chosen at each step is determined by the land cover costs (specified for each land type), the species’ perceptual range (<code>PR</code>) and directional persistence (<code>DP</code>). We set these parameters so that individuals have a perceptual range of <em>50m</em>, use the arithmetic mean method (the default) for calculating effective cost (which tends to emphasise the avoidance of high-cost landscape features), and tend to follow highly correlated paths within the landscape. We also set a constant per-step mortality probability (<code>StepMort</code>).</p>
<p>Once arrived in a new patch, an individual decides to settle or not based on certain settlement rules. Finding suitable habitat is a necessary condition in all cases. Additionally, we set mate availability as requirement, i.e. there has to be at least one individual of the opposite sex present in the patch to be considered suitable for settlement.</p>
<pre class="r"><code>disp &lt;-  Dispersal(Emigration = Emigration(DensDep=T, StageDep=T, 
                                           EmigProb = cbind(0:2,c(0.5,0,0),c(10.0,0,0),c(1.0,0,0)) ), 
                   Transfer = SMS(PR=5, DP=10, Costs = c(1,1,3,5,10,20,50), StepMort = 0.01), 
                   Settlement = Settlement(FindMate = T) )</code></pre>
<p>We can visualise the defined processes by plotting some of the rates and probabilities that we have parameterised:</p>
<pre class="r"><code>par(mfrow=c(1,2))
plotProbs(demo@StageStruct)
plotProbs(disp@Emigration)</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
</div>
<div id="initialisation-simulation" class="section level2">
<h2><span class="header-section-number">2.2</span> Initialisation &amp; simulation</h2>
<p>We choose to initialise our simulation in all initial patches (specified in initial distribution map; in our case only patch #<em>30</em>) at a density of <em>10</em> individuals per hectare, with an equal number of individuals in stages 1 and 2 at their respective minimum age.</p>
<pre class="r"><code># Population is initialised in Patch 30:
init &lt;- Initialise(InitType = 1,       # from loaded species distribution map
                   SpType = 0,         # all suitable cells
                   InitDens = 2,       # user-specified density
                   IndsHaCell = 10,
                   PropStages = c(0,0.5,0.5),
                   InitAge = 0)</code></pre>
<p>We set the simulation time to <em>100</em> years and <em>20</em> replicates, and set the output types to write the files for population, occupancy and range data every year.</p>
<pre class="r"><code>sim &lt;- Simulation(Simulation = 0, 
                  Replicates = 20, 
                  Years = 100,
                  OutIntPop = 1,
                  OutIntOcc = 1,
                  OutIntRange = 1)</code></pre>
<p>As before, we need to stitch all modules together to a parameter master. Within <code>RSsim()</code>, we can also set a seed for the random number generator to make our results reproducible:</p>
<pre class="r"><code>s &lt;- RSsim(batchnum = 3, land = land, demog = demo, dispersal = disp, simul = sim, init = init, seed = 324135)</code></pre>
<p>Run the simulation:</p>
<pre class="r"><code>RunRS(s, dirpath)</code></pre>
</div>
<div id="analyse-output" class="section level2">
<h2><span class="header-section-number">2.3</span> Analyse output</h2>
<p>To analyse the simulation output, we first plot the meta-population results. Note here that - in contrast to the cell-based model from exercise 1 - the plotted occupancy refers to occupied patches rather than cells.</p>
<pre class="r"><code>par(mfrow=c(1,2))
plotAbundance(s, dirpath)
plotOccupancy(s, dirpath)</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>In order to create occupancy maps, we first plot the landscape with the suitable patches in green and the initial patch in red. This color scheme was also used in Fig. 3a of <span class="citation">Bocedi et al. (2014)</span>.</p>
<pre class="r"><code># We have initiated the population in the patch with ID=30. We highlight this in the map.
values(patch30)[values(patch30)&lt;1] &lt;- NA
values(patch)[values(patch)&lt;1] &lt;- NA

levelplot(landsc, margin=F, scales=list(draw=FALSE),at=seq(.5,7.5,by=1), colorkey=F,
        col.regions = rev(brewer.pal(n = 7, name = &quot;Greys&quot;) )) +
    levelplot(patch, margin=F, scales=list(draw=FALSE), col.regions=&quot;green4&quot;) +
    layer(sp.polygons(rasterToPolygons(patch30, dissolve=T), fill=NA, col=&#39;red&#39;,lwd=2))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<pre class="r"><code># Store underlying landscape map display for later:
bg &lt;- function(main=NULL){
    levelplot(landsc, margin=F, scales=list(draw=FALSE),at=seq(.5,7.5,by=1), colorkey=F,
                col.regions = rev(brewer.pal(n = 7, name = &quot;Greys&quot;) ), main=main)
}</code></pre>
<p>To reproduce Fig. 3b of <span class="citation">Bocedi et al. (2014)</span>, we map the mean occupancy probability for each patch in year <em>100</em> (left panel in the paper) as well as the mean time to colonisation (right panel), both calculated over the <em>20</em> replicates. We can use the built-in function <code>ColonisationStats()</code> for this. It calculates the mean occupancy probability of given years as well as the time to colonisation for all replicates:</p>
<pre class="r"><code>col_stats_a &lt;- ColonisationStats(s, dirpath, years = 100, maps = T)

# mean occupancy probability in year 100
head(col_stats_a$occ_prob)</code></pre>
<pre><code>##   patch  100
## 1    15 0.30
## 2    17 0.25
## 3    18 0.00
## 4    20 0.30
## 5    23 1.00
## 6    24 1.00</code></pre>
<pre class="r"><code># time to colonisation
head(col_stats_a$col_time)</code></pre>
<pre><code>##   patch rep.0 rep.1 rep.2 rep.3 rep.4 rep.5 rep.6 rep.7 rep.8 rep.9 rep.10
## 1    15    57    NA    NA    NA    NA    NA    44    24    94    NA     NA
## 2    17    48    NA    NA    NA    NA    NA    NA    71    90    NA     NA
## 3    18    81    NA    NA    NA    NA    NA    NA    NA    NA    NA     NA
## 4    20    31    NA    NA    NA    NA    NA    76     8    56    NA     NA
## 5    23    21    48    59    35    30    63    71    67    67    38     45
## 6    24    10    20    41    16     6    40     5    29    50    19     21
##   rep.11 rep.12 rep.13 rep.14 rep.15 rep.16 rep.17 rep.18 rep.19
## 1     77     80     98     NA     NA     NA     NA     NA     NA
## 2     33     77     NA     NA     NA     NA     75     NA     NA
## 3     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 4     50     65     86     NA     NA     54     NA     NA     NA
## 5     37     51     54     26     47     33     77     36     41
## 6     20     35     36      9     30     12     26      3     21</code></pre>
<p>For mapping the results, we can use the optional raster output: If enabled, the function <code>ColonisationStats()</code> returns a raster stack with the mean occupancy probabilities of the given years as well as a raster with the mean time to colonisation over all replicates. We plot these maps on top of our landscape:</p>
<pre class="r"><code># map occupancy probability
mycol_occprob &lt;- colorRampPalette(c(&#39;blue&#39;,&#39;orangered&#39;,&#39;gold&#39;))
levelplot(col_stats_a$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<pre class="r"><code># map occupancy probability on landscape background. For this, we first define a colorkey function
col.key &lt;- function(mycol, at, space=&#39;bottom&#39;,pos=0.05, height=0.6, width=1) {
    key &lt;- draw.colorkey(
        list(space=space, at=at, height=height, width=width,
         col=mycol)
    )
    key$framevp$y &lt;- unit(pos, &quot;npc&quot;)
    return(key)
}

bg() + levelplot(col_stats_a$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
grid.draw(col.key(mycol_occprob(11),at=seq(0,1,length=11)))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-19-2.png" width="672" /></p>
<pre class="r"><code># map colonisation time
mycol_coltime &lt;- colorRampPalette(c(&#39;orangered&#39;,&#39;gold&#39;,&#39;yellow&#39;,&#39;PowderBlue&#39;,&#39;LightSeaGreen&#39;))
levelplot(col_stats_a$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-19-3.png" width="672" /></p>
<pre class="r"><code># map colonisation time on landscape background
bg() + levelplot(col_stats_a$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
grid.draw(col.key(c(&#39;blue&#39;,mycol_coltime(11)), c(-9,seq(-.001,100,length=11))))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-19-4.png" width="672" /></p>
</div>
</div>
<div id="scenario-b-females-settle-independent-of-males" class="section level1">
<h1><span class="header-section-number">3</span> Scenario b: females settle independent of males</h1>
<p>This experiment was designed to provide an example of how the dispersal behaviour of the species and the specification of settlement rules can change the estimated connectivity of a habitat network. We will relax the mating requirement a little by making it sex-dependent and only setting it for males. This means that female dispersers will settle in suitable patches regardless of males, while males settle only when finding a female.</p>
<pre class="r"><code># Change Settlement rules
disp_b &lt;-  Dispersal(Emigration = Emigration(DensDep=T, StageDep=T, 
                                           EmigProb = cbind(0:2,c(0.5,0,0),c(10.0,0,0),c(1.0,0,0)) ), 
                   Transfer = SMS(PR=5, DP=10, Costs = c(1,1,3,5,10,20,50), StepMort = 0.01), 
                   Settlement = Settlement(FindMate = c(F,T), SexDep=T, Settle=cbind(c(0,1)) ) )

# Update simulation
sim_b &lt;- Simulation(Simulation = 1, 
                  Replicates = 20, 
                  Years = 100,
                  OutIntPop = 1,
                  OutIntOcc = 1,
                  OutIntRange = 1)

# Update parameter master
s_b &lt;- s + disp_b + sim_b</code></pre>
<pre class="r"><code># run simulation
RunRS(s_b, dirpath)</code></pre>
<p>Now, let’s post-process the simulation results and plot the maps.</p>
<pre class="r"><code># Get colonisation stats
col_stats_b &lt;- ColonisationStats(s_b, dirpath, years = 100, maps = T)

# Map occupancy probabilities:
bg() + levelplot(col_stats_b$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
grid.draw(col.key(mycol_occprob(11),at=seq(0,1,length=11)))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<pre class="r"><code># map colonisation time + background
bg() + levelplot(col_stats_b$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
grid.draw(col.key(c(&#39;blue&#39;,mycol_coltime(11)), c(-9,seq(-.001,100,length=11))))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-22-2.png" width="672" /></p>
<p>From both the visualisation and the results, we see that relaxing the mate-finding rules substantially increased the number of occupied patches, their probability of occupancy and the mean time to colonisation. This results in higher functional connectivity of the woodland network over <em>100</em> years.</p>
</div>
<div id="scenario-c-asexual-female-only-model" class="section level1">
<h1><span class="header-section-number">4</span> Scenario c: asexual / female-only model</h1>
<p>Here we change the demography module to represent a female-only model. This change also has important consequences for the dispersal process and potential implications for patterns of colonisation across a landscape. Female-only models assume that males are not limiting, and that the population dynamics are driven only by females. It also means that sexes are not modelled explicitly and it is not possible to account for behaviours like mate-finding in the settlement decisions; females will settle in suitable habitat patches and then will automatically be able to attempt reproduction.</p>
<p>The stage-structure of the model remains the same apart from accounting for the female-only case. In particular, in female-only models, we ignore the male part of the population and offspring. Therefore, we set the fecundity of stage 3 to <em>2.5</em> instead of <em>5.0</em> and the demographic density dependence <em>1/b</em> (<code>K_or_DensDep</code>) to <em>5</em> instead of <em>10</em>. Sex-dependent settlement options are no longer available.</p>
<pre class="r"><code># Change demographic density dependence to half its value of the sexual model
land_c &lt;- ImportedLandscape(LandscapeFile = &quot;landscape_10m_batch.txt&quot;,
                          PatchFile = &quot;woodland_1ha_patchIDs.txt&quot;, 
                          Resolution = 10,
                          Nhabitats = 7,
                          K_or_DensDep = c(5, rep(0,6)),
                          SpDistFile = &quot;patch30.txt&quot;,
                          SpDistResolution = 10)

# Change demography settings
stg_c &lt;- StageStructure(Stages=3, 
                        TransMatrix=matrix(c(0, 1, 0, 0, 0.1, 0.4, 2.5, 0, 0.8), nrow = 3, byrow = F), 
                        MaxAge=1000, 
                        SurvSched=2, 
                        FecDensDep=T)

demo_c &lt;- Demography(StageStruct = stg_c,
                     ReproductionType = 0)   # female-only model

# Remove settlement rules
disp_c &lt;-  Dispersal(Emigration = Emigration(DensDep=T, StageDep=T, 
                                           EmigProb = cbind(0:2,c(0.5,0,0),c(10.0,0,0),c(1.0,0,0)) ), 
                   Transfer = SMS(PR=5, DP=10, Costs = c(1,1,3,5,10,20,50), StepMort = 0.01), 
                   Settlement = Settlement()
)

# Update simulation
sim_c &lt;- Simulation(Simulation = 2,
                  Replicates = 20, 
                  Years = 100,
                  OutIntPop = 1,
                  OutIntOcc = 1,
                  OutIntRange = 1)

# parameter master
s_c &lt;- RSsim(batchnum = 3, land = land_c, demog = demo_c, dispersal = disp_c, simul = sim_c, init = init, seed = 48263)</code></pre>
<pre class="r"><code>RunRS(s_c, dirpath)</code></pre>
<p>Process the output and plot the occupancy maps:</p>
<pre class="r"><code># Get colonisation stats
col_stats_c &lt;- ColonisationStats(s_c, dirpath, years = 100, maps = T)

# Map occupancy probabilities:
bg() + levelplot(col_stats_c$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
grid.draw(col.key(mycol_occprob(11),at=seq(0,1,length=11)))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<pre class="r"><code># Map colonisation time + background
bg() + levelplot(col_stats_c$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
grid.draw(col.key(c(&#39;blue&#39;,mycol_coltime(11)), c(-9,seq(-.001,100,length=11))))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-25-2.png" width="672" /></p>
<p>As we see from the results, the asexual model without mate finding as settlement rule leads to a drastic increase in the overall occupancy of the habitat network after <em>100</em> years.</p>
</div>
<div id="scenario-d-habitat-specific-per-step-mortality" class="section level1">
<h1><span class="header-section-number">5</span> Scenario d: habitat-specific per-step mortality</h1>
<p>In this last simulation, we will demonstrate how <code>RangeshiftR</code> can incorporate more complexity in the way that movement is modelled. We relax the unrealistic assumption that the per-step mortality is constant across all land-cover types, and assign different mortality values to each habitat. To set up this simulation, we use the parameters from scenario a) and only add a modified transfer module. Here, we define <code>StepMort</code> as habitat-dependent by providing a vector with mortality probabilities for each land cover type.</p>
<pre class="r"><code># Update Transfer sub-module within the dispersal module
disp_d &lt;- disp + SMS(PR=5, DP=10, Costs = c(1,1,3,5,10,20,50), 
                     StepMort = c(0,0,0,0.01,0.01,0.02,0.05)
                     )

# Update simulation
sim_d &lt;- Simulation(Simulation = 3,
                  Replicates = 20, 
                  Years = 100,
                  OutIntPop = 1,
                  OutIntOcc = 1,
                  OutIntRange = 1)

# Use parameter master from a) and add new transfer module
s_d &lt;- s + disp_d + sim_d</code></pre>
<p>Run the simulation:</p>
<pre class="r"><code>RunRS(s_d, dirpath)</code></pre>
<p>Process and map results:</p>
<pre class="r"><code># Get colonisation stats
col_stats_d &lt;- ColonisationStats(s_d, dirpath, years = 100, maps = T)

# Map occupancy probabilities:
bg() + levelplot(col_stats_d$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
grid.draw(col.key(mycol_occprob(11),at=seq(0,1,length=11)))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre class="r"><code># map colonisation time + background
bg() + levelplot(col_stats_d$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
grid.draw(col.key(c(&#39;blue&#39;,mycol_coltime(11)), c(-9,seq(-.001,100,length=11))))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-28-2.png" width="672" /></p>
<p>We see that such small changes in the per-step mortality, in interaction with the landscape structure, make a big difference in the results, in this case decreasing the functional connectivity of the network.</p>
</div>
<div id="scenario-comparison" class="section level1">
<h1><span class="header-section-number">6</span> Scenario comparison</h1>
<p>Let’s plot all maps next to each other.</p>
<pre class="r"><code># Plot occupancy probabilities for all scenarios
occ_a &lt;- bg(main=&quot;Scenario A&quot;) + levelplot(col_stats_a$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
occ_b &lt;- bg(main=&quot;Scenario B&quot;) + levelplot(col_stats_b$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
occ_c &lt;- bg(main=&quot;Scenario C&quot;) + levelplot(col_stats_c$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))
occ_d &lt;- bg(main=&quot;Scenario D&quot;) + levelplot(col_stats_d$map_occ_prob, margin=F, scales=list(draw=FALSE), at=seq(0,1,length=11), col.regions=mycol_occprob(11))

grid.arrange(occ_a,occ_b,occ_c,occ_d, ncol=2)
grid.draw(col.key(mycol_occprob(11),at=seq(0,1,length=11), space=&#39;right&#39;,pos=0.5))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<pre class="r"><code># Plot colonisation times for all scenarios
col_a &lt;- bg(main=&quot;Scenario A&quot;) + levelplot(col_stats_a$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
col_b &lt;- bg(main=&quot;Scenario B&quot;) + levelplot(col_stats_b$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
col_c &lt;- bg(main=&quot;Scenario C&quot;) + levelplot(col_stats_c$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))
col_d &lt;- bg(main=&quot;Scenario D&quot;) + levelplot(col_stats_d$map_col_time, margin=F, scales=list(draw=FALSE), at=c(-9,seq(-.001,100,length=11)), col.regions=c(&#39;blue&#39;,mycol_coltime(11)))

grid.arrange(col_a,col_b,col_c,col_d, ncol=2)
grid.draw(col.key(c(&#39;blue&#39;,mycol_coltime(11)), c(-9,seq(-.001,100,length=11)), space=&#39;right&#39;,pos=0.5))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-29-2.png" width="672" /></p>
</div>
<div id="dispersal-heatmap" class="section level1">
<h1><span class="header-section-number">7</span> Dispersal heatmap</h1>
<p>As an additional tool to analyse the connectivity of a landscape and to assess how the matrix is used by dispersing individuals, the option to output a dispersal heatmap is provided (available only in case of SMS as the transfer method). In this section, we re-run scenario c) as an example to show how to create and plot such a heatmap.</p>
<p>We use an alternative option for the initialisation of the population. Instead of providing a species distribution map, a text file can be given that specifies a list of initial patches (or cells, in a cell-based model) and initial local populations. This text file must contain a specific list of columns that also depend on your model settings (please see <code>?Initialise</code>). For sexual models, you need to include the column “Sex”; for stage-structured models, you need to include the columns “Age” and “Stage”. For the correct format of the initial individuals file, please refer to the documentation and the example file given with this tutorial.</p>
<p>The corresponding initialisation module is specified like this:</p>
<pre class="r"><code># alternative initialisation in patch 30:
init_alt &lt;- Initialise(InitType = 2, # = from initial individuals list file
                       InitIndsFile = &quot;initial_inds_c.txt&quot;)</code></pre>
<p>The output of the SMS heatmaps is enabled in the simulation module using the parameter <code>SMSHeatMap</code>.</p>
<pre class="r"><code># update simulation module
sim_c2 &lt;- Simulation(SMSHeatMap = T,
                     Simulation = 4,
                     Replicates = 20,
                     Years = 100,
                     OutIntPop = 0,
                     OutIntRange = 0)</code></pre>
<p>With these changes and all other modules from scenario c) as defined above, we create the modified parameter master and run the simulation.</p>
<pre class="r"><code># parameter master
s_c2 &lt;- s_c+ sim_c2</code></pre>
<pre class="r"><code>RunRS(s_c2, dirpath)</code></pre>
<p>For each replicate, we now obtain an SMS heatmap that is saved in the folder ‘Output_Maps’ as an ASCII raster file. The heatmap values represent the number of visits by a dispersing individual to each non-habitat cell. That is, during the dispersal phase each step that was taken by any individual increases the counter of the cell in which this step ended. Thus, the resulting dispersal heatmap can be used to assess those parts of the landscape matrix that are frequently used for dispersal, whether it was successful or not.</p>
<p>Let’s first look at one replicate only and plot it:</p>
<pre class="r"><code>levelplot(raster(paste0(dirpath,&quot;Output_Maps/Batch3_Sim4_Land1_Rep1_Visits.txt&quot;)),
          par.settings=BTCTheme(), colorkey=T, margin=F, scales=list(draw=FALSE))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<p>The matrix around the initial patch and the first colonised patches appears thoroughly explored. Further away from the initial patch, the number of visits decreases and parts of individual dispersal trajectories are discernible.</p>
<p>Because movement is stochastic, the number of visits per cell and the colonisation of empty patches are different for each replicate. In order to take into account this variance, we average over all replicates and plot the resulting heatmap:</p>
<pre class="r"><code># create a raster stack with all replicates as layers
heatmaps_stack &lt;- stack()
for(rep in 0:(s_c2@simul@Replicates-1)){
    heatmaps_stack &lt;- addLayer(heatmaps_stack, 
                               paste0(dirpath, &quot;Output_Maps/Batch&quot;, 
                                      s_c2@control@batchnum, &quot;_Sim&quot;, 
                                      s_c2@simul@Simulation, &quot;_Land&quot;, 
                                      s_c2@land@LandNum,&quot;_Rep&quot;,rep ,&quot;_Visits.txt&quot;))
}
# average over all layers
heatmaps_mean &lt;- stackApply(heatmaps_stack, indices=1, fun=mean)</code></pre>
<p>We create a non-linear color scale, in which the color changes more rapidly for small numbers of visits than higher ones:</p>
<pre class="r"><code># create exponential color scale
res &lt;- 20
exp &lt;- 3
lim &lt;- max(values(heatmaps_mean),na.rm = T)
my.at &lt;- seq(1,lim^(1/exp),length.out=res)^exp

levelplot(heatmaps_mean,
          col.regions=hcl.colors(res, &quot;Inferno&quot;, rev = T),
          at = my.at, margin=F, scales=list(draw=FALSE))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<p>Note that individuals cannot cross the landscape boundaries, so that their paths tend to follow and sometimes accumulate along the borders. To avoid simulation artifacts resulting from this behaviour, there should be sufficient space between relevant habitat patches and the landscape boundaries.</p>
<p>Last, let’s overlay the averaged heatmap on the landscape background. Here, you can nicely see that the movement in the landscape depends a lot on the landscape context and the costs associated to each landcover type.</p>
<pre class="r"><code>bg() + levelplot(heatmaps_mean, 
                 col.regions=hcl.colors(res, &quot;Inferno&quot;, rev = T, alpha=.8),
                 at=my.at, margin=F, scales=list(draw=FALSE))</code></pre>
<p><img src="tutorial_2_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Bocedi2014">
<p>Bocedi, G., S.C.F. Palmer, G. Pe’er, R.K. Heikkinen, Y.G. Matsinos, K. Watts, and J.M.J. Travis. 2014. “RangeShifter: A Platform for Modelling Spatial Eco-Evolutionary Dynamics and Species’ Responses to Environmental Changes.” <em>Methods in Ecology and Evolution</em> 5 (4): 388–96. <a href="https://doi.org/10.1111/2041-210X.12162">https://doi.org/10.1111/2041-210X.12162</a>.</p>
</div>
</div>
</div>

<!DOCTYPE html>
<html>

<br>
<hr />
<div id="footer">
<p>Anne-Kathleen Malchow, Greta Bocedi, Steve Palmer, Justin Travis & Damaris Zurell <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" >(CC BY-NC-ND 4.0)</a>.  </p>
</div>

</html>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
